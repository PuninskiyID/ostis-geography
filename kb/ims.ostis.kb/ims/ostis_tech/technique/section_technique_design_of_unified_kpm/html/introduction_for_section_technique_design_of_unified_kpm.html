<p>В процессе разработки машины обработки знаний конкретной <sc_element sys_idtf  = "ostis_system">ostis-системы</sc_element> можно выделить несколько этапов. Рассмотрим подробнее каждый из этапов.</p>
<p><b>Этап1. Формирование требований и спецификация машины обработки знаний</b></p>
<p>На данном этапе необходимо четко выделить задачи, которые должна решать проектируемая машина обработки знаний, продумать предполагаемые способы их решения и на основе данного анализа определить место будущей машины обработки знаний в общей иерархии машин, предлагаемой в рамках <sc_element sys_idtf  = "technology_OSTIS">Технологии OSTIS</sc_element>. Важность данного этапа заключается с в том, что при правильной классификации существует вероятность того, что в составе библиотеки компонентов уже есть реализованный вариант требуемой машины. В противном случае, тем не менее, у разработчика появляется возможность включить созданную машину в библиотеку компонентов для последующих использований. Данные факты обусловлены тем, что <sc_element sys_idtf  = "structure"> структура </sc_element> библиотеки компонентов машин обработки знаний основана на семантической типологии таких машин и, соответственно, их компонентов.</p>
<p>При недостаточно четкой спецификации и классификации разрабатываемой машины повышается вероятность того, что подходящая машина не будет найдена в библиотеке компонентов, даже в случае, если она там есть, а вновь разработанная машина не сможет быть включена в библиотеку. Таким образом, идея многократного использования уже разработанных компонентов будет нарушена, что существенно повысит затраты на разработку такой машины.</p>

<p><b>Этап2. Формирование коллектива <sc_element sys_idtf  = "sc_agent">sc-агентов </sc_element>, входящих в состав разрабатываемой машины</b></p>
<p>В случае, когда найти в библиотеке готовую машину обработки знаний, удовлетворяющую всем предъявляемым требованиям, не представляется возможным, необходимо выделить и специфицировать все компоненты такой машины.
Результатом данного этапа является перечень полностью специфицированных <sc_element sys_idtf  = "sc_agent">sc-агентов </sc_element>, которые войдут в состав разрабатываемой машины, с их иерархией вплоть до атомарных <sc_element sys_idtf  = "sc_agent">sc-агентов </sc_element>. В рамках данного этапа очень важно проектировать коллектив агентов таким образом, чтобы максимально задействовать уже имеющиеся в библиотеке многократно используемые компоненты, а при отсутствии нужного компонента – иметь возможность включить его в библиотеку после реализации. В качестве таких компонентов, в зависимости от сложности разрабатываемой машины, могут выступать как атомарные <sc_element sys_idtf  = "sc_agent">sc-агенты </sc_element>, так и целые коллективы <sc_element sys_idtf  = "sc_agent">sc-агентов </sc_element> (неатомарные <sc_element sys_idtf  = "sc_agent">sc-агенты </sc_element>).</p>
<p>При разработке перечня агентов (в том числе – их спецификаций) необходимо соблюдать ряд принципов:</p>
<ul>
<li>Каждый разрабатываемый <sc_element sys_idtf  = "sc_agent">sc-агент </sc_element>должен быть по возможности предметно независим, т.е. во множество ключевых узлов данного sc-­агента не должны входить <sc_element sys_idtf  = "concept"> понятия </sc_element>, имеющие отношение непосредственно к рассматриваемой <sc_element sys_idtf  = "subject_domain"> предметной области </sc_element>. Исключение составляют <sc_element sys_idtf  = "concept"> понятия </sc_element> из общих <sc_element sys_idtf  = "subject_domain"> предметных областей </sc_element>, которые носят междисциплинарный характер (например, отношение <sc_element sys_idtf  = "nrel_inclusion">включение</sc_element>* или <sc_element sys_idtf  = "concept"> понятие </sc_element> действие). Данное правило может также быть нарушено в случае, если <sc_element sys_idtf  = "sc_agent">sc-агент </sc_element>является вспомогательным и ориентирован на обработку какого-либо конкретного класса объектов (например, <sc_element sys_idtf  = "sc_agent">sc-агенты </sc_element>, выполняющие арифметические вычисления могут напрямую работать с конкретными отношениями <b><sc_element sys_idtf  = "nrel_sum_of_numbers"> сложение</sc_element>*</b> и <b><sc_element sys_idtf  = "nrel_multiplication_of_numbers"> произведение </sc_element>*</b> и т.п.). Всю необходимую для решения задачи информацию <sc_element sys_idtf  = "sc_agent">sc-агент </sc_element>должен извлекать из семантической окрестности соответствующего <sc_element sys_idtf  = "question_initiated">инициированного действия </sc_element>. Очевидно, что sc-агент, разработанный с учетом указанных требований, может быть использован при проектировании большего числа <sc_element sys_idtf  = "ostis_system">ostis-систем</sc_element>, чем в случае, если бы он был реализован с ориентацией на конкретную частную <sc_element sys_idtf  = "subject_domain"> предметную область </sc_element>. После завершения разработки и отладки такой <sc_element sys_idtf  = "sc_agent">sc-агент </sc_element>должен быть включен в Библиотеку многократно используемых <sc_element sys_idtf  = "abstract_sc_agent"> абстрактных sc-агентов </sc_element>.</li>
<li>Не стоит путать <sc_element sys_idtf  = "concept"> понятия </sc_element> <sc_element sys_idtf  = "sc_agent">sc-агент </sc_element>и агентная программа (в том числе – <sc_element sys_idtf  = "agent_scp_program"> агентная scp-программа </sc_element>). Взаимодействие <sc_element sys_idtf  = "sc_agent">sc-агентов </sc_element> осуществляется исключительно через общую память, каждый <sc_element sys_idtf  = "sc_agent">sc-агент </sc_element>реагирует на появление в <sc_element sys_idtf  = "sc_memory">sc-памяти </sc_element>и некоторой <sc_element sys_idtf  = "structure"> структуры </sc_element> . Таким образом, каждому <sc_element sys_idtf  = "sc_agent">sc-агенту </sc_element> соответствует некоторое условие инициирования, и одна агентная программа, которая запускается автоматически при возникновении в <sc_element sys_idtf  = "sc_memory">sc-памяти </sc_element>и соответствующего условия инициирования. При этом в рамках этой программы могут сколько угодно раз вызываться различные подпрограммы. Однако, не стоит путать инициирование <sc_element sys_idtf  = "sc_agent">sc-агента </sc_element>, которое осуществляется при появлении в <sc_element sys_idtf  = "sc_memory">sc-памяти </sc_element>и соответствующей конструкции, и вызов подпрограммы другой программой, который предполагает явное указание вызываемой подпрограммы и перечня ее параметров.</li>
<li>Каждый <sc_element sys_idtf  = "sc_agent">sc-агент </sc_element>должен самостоятельно проверять полноту соответствия своего условия инициирования текущему состоянию <sc_element sys_idtf  = "sc_memory">sc-памяти </sc_element>и. В процессе решения какой-либо задачи может возникнуть ситуация, когда на появление одной и той же <sc_element sys_idtf  = "structure"> структуры </sc_element>  среагировали несколько <sc_element sys_idtf  = "sc_agent">sc-агентов </sc_element>. В таком случае выполнение продолжают только те из них, условие инициирования которых полностью соответствует сложившейся ситуации. Остальные <sc_element sys_idtf  = "sc_agent">sc-агенты </sc_element> в данном случае прекращают выполнение и возвращаются в режим ожидания. Выполнение данного принципа достигается за счет тщательного уточнения спецификаций разрабатываемых <sc_element sys_idtf  = "sc_agent">sc-агентов </sc_element>. В общем случае условия инициирования у нескольких <sc_element sys_idtf  = "sc_agent">sc-агентов </sc_element> могут совпадать, однако такая ситуация является нежелательной и может быть реализована в том случае, если указанные <sc_element sys_idtf  = "sc_agent">sc-агенты </sc_element> не вносят существенных изменений в ту область памяти, с которой работают остальные <sc_element sys_idtf  = "sc_agent">sc-агенты </sc_element>.</li>
<li>Необходимо помнить, что неатомарный <sc_element sys_idtf  = "sc_agent">sc-агент </sc_element>с точки зрения других <sc_element sys_idtf  = "sc_agent">sc-агентов </sc_element>, не входящих в его состав, должен функционировать как целостный sc-агент, что накладывает определенные требования на спецификации атомарных <sc_element sys_idtf  = "sc_agent">sc-агентов </sc_element> входящих в его состав. Как минимум, необходимо, чтобы в составе неатомарного <sc_element sys_idtf  = "sc_agent">sc-агента </sc_element> присутствовал хотя бы один атомарный sc-агент, условие инициирования которого полностью совпадает с условием инициирования данного неатомарного <sc_element sys_idtf  = "sc_agent">sc-агента </sc_element>.</li>
<li>При необходимости реализации нового <sc_element sys_idtf  = "sc_agent">sc-агента </sc_element> следует руководствоваться следующими принципами выделения атомарных <sc_element sys_idtf  = "abstract_sc_agent"> абстрактных sc-агентов </sc_element>:
<ul>
<li>проектируемый <sc_element sys_idtf  = "sc_agent">sc-агент </sc_element>должен быть максимально универсальным (как указано выше), что позволит в дальшейшем использовать его при разработке машин обработки знаний максимального возможного числа <sc_element sys_idtf  = "ostis_system">ostis-систем</sc_element>. При этом универсальность предполагает не только минимизацию числа ключевых узлов <sc_element sys_idtf  = "sc_agent">sc-агента </sc_element>, но и выделение класса действий, выполняемых данным <sc_element sys_idtf  = "sc_agent">sc-агентом </sc_element> таким образом, чтобы имело смысл включить данный <sc_element sys_idtf  = "sc_agent">sc-агент </sc_element>в Библиотеку многократно используемых <sc_element sys_idtf  = "abstract_sc_agent"> абстрактных sc-агентов </sc_element> и использовать его при разработке машин обработки знаний других <sc_element sys_idtf  = "ostis_system">ostis-систем</sc_element>. Не следует искусственно увязывать ряд действий в один <sc_element sys_idtf  = "sc_agent">sc-агент </sc_element>и наоборот, расчленять одно самодостаточное действие на поддействия. Это вызовет сложности восприятия принципов работы <sc_element sys_idtf  = "sc_agent">sc-агента </sc_element> разработчиками и не позволит использовать <sc_element sys_idtf  = "sc_agent">sc-агент </sc_element>в ряде систем (например, в обучающих системах, которые должны объяснять ход решения пользователю);</li>
<li>акт деятельности каждого <sc_element sys_idtf  = "sc_agent">sc-агента </sc_element> (выполняемое данным <sc_element sys_idtf  = "sc_agent">sc-агентом </sc_element> действие) должен быть логически целостным и завершенным. Следует помнить, что все <sc_element sys_idtf  = "sc_agent">sc-агенты </sc_element> взаимодействуют исключительно через общую память и избегать ситуаций, в которых инициирование одного <sc_element sys_idtf  = "sc_agent">sc-агента </sc_element> осуществляется путем явной генерации известного условия инициирования другим <sc_element sys_idtf  = "sc_agent">sc-агентом </sc_element> (то есть по сути, явным непосредственным вызовом одного <sc_element sys_idtf  = "sc_agent">sc-агента </sc_element> другим);</li>
<li>следует учитывать тот факт, что все <sc_element sys_idtf  = "sc_agent">sc-агенты </sc_element> работают параллельно, в связи с чем имеет смысл выделять в отдельные <sc_element sys_idtf  = "sc_agent">sc-агенты </sc_element> те относительно крупные фрагменты реализации некоторого общего алгоритма, которые могут выполняться независимо друг от друга;</li></ul></li>
<li>При объединении <sc_element sys_idtf  = "sc_agent">sc-агент </sc_element>в коллективы рекомендуется проектировать их таким образом, чтобы они могли быть использованы не только как часть рассматриваемого неатомарного <sc_element sys_idtf  = "abstract_sc_agent"> абстрактного sc-агента </sc_element>. В случае, если это не представляется возможным и некоторые <sc_element sys_idtf  = "sc_agent">sc-агенты </sc_element>, будучи отделенными от коллектива, теряют смысл, необходимо указать данный факт при документировании рассматриваемых <sc_element sys_idtf  = "sc_agent">sc-агентов </sc_element>.</li>
<li>Фактическим инициатором запуска <sc_element sys_idtf  = "sc_agent">sc-агента </sc_element> посредством общей памяти (автором соответствующей конструкции) может быть как непосредственно пользователь системы, так и другой sc-агент. При этом это никак не должно отражаться в работе самого <sc_element sys_idtf  = "sc_agent">sc-агента </sc_element>. Необходимость вывода (трансляции) какого-либо фрагмента базы знаний пользователю отслеживается специальными <sc_element sys_idtf  = "sc_agent">sc-агента </sc_element>ми пользовательского интерфейса.</li></ul>

<p><b>Этап3. Разработка алгоритмов атомарных <sc_element sys_idtf  = "sc_agent">sc-агентов </sc_element></b></p>
<p>В рамках данного этапа необходимо продумать алгоритм работы каждого разрабатываемого атомарного <sc_element sys_idtf  = "sc_agent">sc-агента </sc_element>. Разработка алгоритма подразумевает выделение в нем логически целостных фрагментов, которые могут быть реализованы как отдельные <sc_element sys_idtf  = "scp_program">scp-программы </sc_element>, в том числе, выполняемые параллельно. Таким образом, появляется необходимость говорить не только о Библиотеке многократно используемых <sc_element sys_idtf  = "abstract_sc_agent"> абстрактных sc-агентов </sc_element>, но и Библиотеке многократно используемых программ обработки sc-текстов на различных языках программирования, в том числе Библиотеке многократно используемых <sc_element sys_idtf  = "scp_program">scp-программ </sc_element>. Благодаря этому, часть <sc_element sys_idtf  = "scp_program">scp-программ </sc_element>, реализующих алгоритм работы некоторого <sc_element sys_idtf  = "sc_agent">sc-агента </sc_element> может быть заимствована из соответствующей библиотеки.</p>
<p>Важно помнить, что если в процессе работы <sc_element sys_idtf  = "sc_agent">sc-агент </sc_element>генерирует в памяти какие-либо временные <sc_element sys_idtf  = "structure"> структуры </sc_element> , то при завершении работы он обязан удалять всю информацию, использование которой в системе более нецелесообразно (убрать за собой информационный «мусор»). Исключение составляют ситуации, когда подобная информация необходима нескольким <sc_element sys_idtf  = "sc_agent">sc-агента </sc_element>м для решения одной задачи, однако после решения задачи информация становится бесполезной или избыточной и требует удаления. В данном случае ни один из <sc_element sys_idtf  = "sc_agent">sc-агентов </sc_element> может оказаться не в состоянии удалить информационный мусор. В таком случае возникает необходимость говорить о включении в состав машины специализированных <sc_element sys_idtf  = "sc_agent">sc-агентов </sc_element>, задачей которых является выявление и уничтожение информационного мусора.</p>

<p><b>Этап4. Разработка <sc_element sys_idtf  = "scp_program">scp-программ </sc_element></b></p>
<p>Конечным этапом непосредственно разработки является реализация специфицированных ранее <sc_element sys_idtf  = "scp_program">scp-программ </sc_element> или, при необходимости, программ, реализуемых на уровне платформы.</p>

<p><b>Этап5. Верификация разработанных компонентов</b></p>
<p>Верификация разработанных компонентов может осуществляться как вручную, так и с использованием специфицированных средств, входящих в состав подсистемы проектирования машин обработки знаний по <sc_element sys_idtf  = "technology_OSTIS">Технологии OSTIS</sc_element>.</p>

<p><b>Этап6. Отладка разработанных компонентов. Исправление ошибок </b></p>
<p>Этап отладки разработанных компонентов в свою очередь можно также условно разделить на более частные этапы:</p>
<ul>
<li>отладка отдельных <sc_element sys_idtf  = "scp_program">scp-программ </sc_element> или программ, реализуемых на уровне платформы;</li>
<li>отладка отдельных атомарных <sc_element sys_idtf  = "sc_agent">sc-агентов </sc_element>;</li>
<li>отладка неатомарных <sc_element sys_idtf  = "sc_agent">sc-агентов </sc_element>, входящих в состав машины обработки знаний;</li>
<li>отладка всей машины обработки знаний;</li></ul>