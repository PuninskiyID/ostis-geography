<p> <u> Общие принципы организации взаимодействия <b><sc_element sys_idtf  = "sc_agent">sc-агентов</sc_element></b> и пользователей <b><sc_element sys_idtf  = "ostis_system">ostis-системы</sc_element></b> через общую <b><sc_element sys_idtf  = "sc_memory">sc-память</sc_element></b>. </u> </p>
<ul>
<li> Каждая <b><sc_element sys_idtf  = "ostis_system">ostis-система</sc_element></b> представляет собой многоагентную систему, агенты которой взаимодействуют между собой только(!) через общую для них <b><sc_element sys_idtf  = "sc_memory">sc-память</sc_element></b>. При этом пользователи <b><sc_element sys_idtf  = "ostis_system">ostis-системы</sc_element></b> также считаются агентами этой системы. Кроме того, <b><sc_element sys_idtf  = "sc_agent">sc-агенты</sc_element></b> делятся на <b><sc_element sys_idtf  = "inside_abstract_sc_agent">внутренние</sc_element></b>, <b><sc_element sys_idtf  = "receptor_abstract_sc_agent">рецепторные</sc_element></b> и <b><sc_element sys_idtf  = "effector_abstract_sc_agent">эффекторные</sc_element></b>. Взаимодействие между агентами через общую <b><sc_element sys_idtf  = "sc_memory">sc-память</sc_element></b> сводится к следующим видам действий: </li>
<ol>
<li> К использованию общедоступных для соответствующей группы агентов части хранимой <b><sc_element sys_idtf  = "knowledge_base">базы знаний</sc_element></b>. В простейшем случае по уровню прав доступа агенты <b><sc_element sys_idtf  = "ostis_system">ostis-системы</sc_element></b> разбиваются на две группы – главные администраторы <b><sc_element sys_idtf  = "knowledge_base">базы знаний</sc_element></b> (их может быть несколько) вместе с обслуживающими их <b><sc_element sys_idtf  = "sc_agent">sc-агентами</sc_element></b> и все остальные агенты; </li>
<li> К формированию (генерации) новых фрагментов <b><sc_element sys_idtf  = "knowledge_base">базы знаний</sc_element></b> и/или к корректировке (редактированию) каких-либо фрагментов доступной части <b><sc_element sys_idtf  = "knowledge_base">базы знаний</sc_element></b>; </li>
<li> К интеграции (погружению) новых и/или обновленных фрагментов в состав доступной части <b><sc_element sys_idtf  = "knowledge_base">базы знаний</sc_element></b>; </li>
</ol>
<li> Пользователь <b><sc_element sys_idtf  = "ostis_system">ostis-системы</sc_element></b> не может сам непосредственно выполнить какое-либо действие в <b><sc_element sys_idtf  = "sc_memory">sc-памяти</sc_element></b>, но он может средствами пользовательского интерфейса инициировать построение (генерацию, формирование в <b><sc_element sys_idtf  = "sc_memory">sc-памяти</sc_element></b>) <b><sc_element sys_idtf  = "set">sc-текста</sc_element></b>, являющегося спецификацией действия в <b><sc_element sys_idtf  = "sc_memory">sc-памяти</sc_element></b>, выполняемого либо одним <b><sc_element sys_idtf  = "atomic_abstract_sc_agent">атомарным sc-агентом</sc_element></b> за один акт, либо одним <b><sc_element sys_idtf  = "atomic_abstract_sc_agent">атомарным sc-агентом</sc_element></b> за несколько актов, либо коллективом <b><sc_element sys_idtf  = "sc_agent">sc-агентов</sc_element></b>. В спецификации каждого такого действия в <b><sc_element sys_idtf  = "sc_memory">sc-памяти</sc_element></b>, инициированного пользователем, этот пользователь указывается как заказчик этого действия. Таким образом, пользователь <b><sc_element sys_idtf  = "ostis_system">ostis-системы</sc_element></b> дает поручения (задания, команды) <b><sc_element sys_idtf  = "sc_agent">sc-агентам</sc_element></b> этой системы на выполнение различных специфицируемых им действий в <b><sc_element sys_idtf  = "sc_memory">sc-памятью</sc_element></b>. </li>
<li> Каждый <b><sc_element sys_idtf  = "sc_agent">sc-агент</sc_element></b>, выполняя некоторое действие в <b><sc_element sys_idtf  = "sc_memory">sc-памяти</sc_element></b>, должен «помнить», что <b><sc_element sys_idtf  = "sc_memory">sc-память</sc_element></b>, над которой он работает, является общим ресурсом не только для него, но и для всех остальных <b><sc_element sys_idtf  = "sc_agent">sc-агентов</sc_element></b>, работающих над этой же <b><sc_element sys_idtf  = "sc_memory">sc-памятью</sc_element></b>. Поэтому <b><sc_element sys_idtf  = "sc_agent">sc-агент</sc_element></b> должен соблюдать определенную этику поведения в коллективе таких <b><sc_element sys_idtf  = "sc_agent">sc-агентов</sc_element></b>, которая должна минимизировать помехи, которые он создает другим <b><sc_element sys_idtf  = "sc_agent">sc-агентам</sc_element></b>. </li>
<li> Деятельность каждого агента <b><sc_element sys_idtf  = "ostis_system">ostis-системы</sc_element></b> дискретна и представляет собой множество элементарных действий (актов). При этом при выполнении практически каждого акта агент выделяет некий фрагмент <b><sc_element sys_idtf  = "knowledge_base">базы знаний</sc_element></b>, который вообще не должен быть «виден» другим агентам (только ему самому) и/или некоторый фрагмент <b><sc_element sys_idtf  = "knowledge_base">базы знаний</sc_element></b>, который может быть «виден», но не может изменяться другими агентами. Указанная <b><sc_element sys_idtf  = "nrel_lock">блокировка</sc_element></b> – это своего рода «забор» (ограждение), через который другим агентам перелезать запрещено. Эта <b><sc_element sys_idtf  = "nrel_lock">блокировка</sc_element></b> устанавливается самим агентом при выполнении соответствующего акта и снимается им же на последнем этапе выполнения этого акта. </li>
<li> Если некий <b><sc_element sys_idtf  = "sc_agent">sc-агент</sc_element></b> выполняет некоторое действие в <b><sc_element sys_idtf  = "sc_memory">sc-памятью</sc_element></b>, то он на время выполнения этого действия может: </li>
<ol>
<li>Запретить другим <b><sc_element sys_idtf  = "sc_agent">sc-агентам</sc_element></b> изменять состояние некоторых <b><sc_element sys_idtf  = "sc_element">sc-элементов</sc_element></b>, хранимых в <b><sc_element sys_idtf  = "sc_memory">sc-памяти</sc_element></b> – удалять их, изменять тип; </li>
<li> Запретить другим <b><sc_element sys_idtf  = "sc_agent">sc-агентам</sc_element></b> добавлять или удалять элементы некоторых <b><sc_element sys_idtf  = "set">множеств</sc_element></b>, обозначаемых соответствующими <b><sc_element sys_idtf  = "sc_node">sc-узлами</sc_element></b>; </li>
<li> Запретить другим <b><sc_element sys_idtf  = "sc_agent">sc-агентам</sc_element></b> доступ на просмотр некоторых <b><sc_element sys_idtf  = "sc_element">sc-элементов</sc_element></b>, то есть эти <b><sc_element sys_idtf  = "sc_element">sc-элементы</sc_element></b> становятся полностью «невидимыми» (полностью заблокированными) для других <b><sc_element sys_idtf  = "sc_agent">sc-агентов</sc_element></b> но только на время выполнения соответствующего действия. </li>
</ol>

<p> Указанные <b><sc_element sys_idtf  = "nrel_lock">блокировки</sc_element></b> должны быть полностью сняты до завершения выполнения соответствующего действия. Подчеркнем, что число <b><sc_element sys_idtf  = "sc_element">sc-элементов</sc_element></b>, блокируемых на время выполнения некоторого действия, в основном входят атомарные и неатомарные связки, и не должны входить <b><sc_element sys_idtf  = "sc_node">sc-узлы</sc_element></b>, обозначающие бесконечные классы каких-либо сущностей, и, тем более, <b><sc_element sys_idtf  = "sc_node">sc-узлы</sc_element></b>, обозначающие различные понятия (ключевые классы различных <b><sc_element sys_idtf  = "subject_domain">предметных областей</sc_element></b>). </p>

<p> Этичное (неэгоистичное) поведение <b><sc_element sys_idtf  = "sc_agent">sc-агента</sc_element></b>, касающееся <b><sc_element sys_idtf  = "nrel_lock">блокировки</sc_element></b> <b><sc_element sys_idtf  = "sc_element">sc-элементов</sc_element></b> (то есть ограничения к ним доступа другим <b><sc_element sys_idtf  = "sc_agent">sc-агентам</sc_element></b>) предполагает соблюдение следующих правил: </p>
<ol>
<li> Не следует блокировать больше <b><sc_element sys_idtf  = "sc_element">sc-элементов</sc_element></b>, чем это необходимо, то есть не следует «жадничать»; </li>
<li> Как только для какого-либо <b><sc_element sys_idtf  = "sc_element">sc-элемента</sc_element></b> необходимость его блокировки отпадает до завершения выполнения соответствующего действия, этот <b><sc_element sys_idtf  = "sc_element">sc-элемент</sc_element></b> желательно сразу деблокировать (снять <b><sc_element sys_idtf  = "nrel_lock">блокировку</sc_element></b>); </li>
</ol>

<p> Для того, чтобы <b><sc_element sys_idtf  = "sc_agent">sc-агент</sc_element></b> проверил возможность работы с каким-либо произвольным <b><sc_element sys_idtf  = "sc_element">sc-элементом</sc_element></b>, он должен либо убедиться в том, что этот <b><sc_element sys_idtf  = "sc_element">sc-элемент</sc_element></b> не входит во <b><sc_element sys_idtf  = "set">множество</sc_element></b> «полностью заблокированный sc-элемент», либо убедиться в том, что указанный <b><sc_element sys_idtf  = "sc_element">sc-элемент</sc_element></b> входит в указанное <b><sc_element sys_idtf  = "set">множество</sc_element></b>, но при это связан отношением полностью заблокированный sc-элемент* с действием, выполняемым этим <b><sc_element sys_idtf  = "sc_agent">sc-агентом</sc_element></b>. Очевидно, что больших затрат времени указанная проверка не потребует. </p>

<p> Особой группой полностью заблокированных sc-элементов (на время выполнения действия <b><sc_element sys_idtf  = "sc_agent">sc-агентом</sc_element></b>) являются вспомогательные sc-элементы («леса»), создаваемые только на время выполнения этого действия. Эти <b><sc_element sys_idtf  = "sc_element">sc-элементы</sc_element></b> в конце выполнения действия должны не деблокироваться, а удаляться. </p>

<li> Если действие в <b><sc_element sys_idtf  = "sc_memory">sc-памяти</sc_element></b>, выполняемое <b><sc_element sys_idtf  = "sc_agent">sc-агентом</sc_element></b>, завершилось (т.е. стало прошлой сущностью), то <b><sc_element sys_idtf  = "sc_agent">sc-агент</sc_element></b> оформляет результат («сухой остаток») этого действия, указывая (1) удаленные sc-элементы и (2) сгенерированные sc-элементы. Это необходимо, если нам придется сделать откат этого действия, т.е возвратиться к состоянию <b><sc_element sys_idtf  = "knowledge_base">базы знаний</sc_element></b> до выполнения указанного действия; </li>
</ul>
