<html>
	<head>
		<style>
  		 	p { text-indent: 20px; }			
   			.fig { text-align: center; }
			table { margin: auto; }
  		</style>
	</head>
	<body>
		<meta http-equiv="content-type" content="text/html; charset=utf-8" />
		<p>
		На основе унифицированных семантических сетей (т.е. на основе SC-кода) необходимо обеспечить построение <b>унифицированных семантических моделей информационного поиска</b> (унифицированных семантических моделей ассоциативного доступа к информации, хранимой в семантической памяти). 
		</p>
		<p>
		Ассоциативный доступ – это доступ, основанный не (!) на знании того, где находится искомая (требуемая) информация (в частности, на знании адреса или имени соответствующей области памяти), а на знании того, как искомая информация связана с известной информацией, хранимой в памяти, т.е. на знании некоторой спецификации искомой информации.
		</p>
		<p>
		Эффективность организации информационного поиска в базе знаний компьютерной системы во многом определяет эффективность самой компьютерной системы. Это обусловлено тем, что время, затрачиваемое компьютерной системой на поиск нужных в текущий момент знаний и навыков, занимает, мягко говоря, не меньше половины времени затрачиваемого на решение задачи в целом.
		</p>
		<p>
		Унифицированная семантическая модель информационного поиска, которую будем называть <b>sc-моделью информационного поиска</b>, включает в себя:
		</p>
		<ol>
			<li><b>SC-язык вопросов, действий и задач</b>, с помощью которого в виде <i><sc_element sys_idtf = "set">sc-текстов</sc_element></i> осуществляется описание (спецификация) запрашиваемых (искомых) фрагментов всего интегрированного sc-текста, хранимого в текущий момент в sc-памяти (т.е. sc-текста, который является sc-моделью базы знаний).</li>
			<li><b>SC-язык оформления ответов</b>, с помощью которого осуществляется явное выделение sc-текстов, являющихся ответами, и явное описание их связи с явно выделенными sc-текстами, которые представляют вопросы, соответствующий указанным ответам.</li>
			<li>Семейство информационно-поисковых <i><sc_element sys_idtf = "sc_agent">sc-агентов</sc_element></i>, каждый из которых реагирует на соответствующий ему тип <i><sc_element sys_idtf = "question">действия</sc_element></i> (которое при этом должно быть инициировано) и выполняет соответствующую поисковую процедуру в sc-памяти.</li>
		</ol>
		<p>
		Будем понимать под <i><sc_element sys_idtf = "question">вопросом</sc_element></i> задачу, направленную на удовлетворение информационной потребности некоторого субъекта-заказчика.
		</p>
		<p>
		Семантическая типология вопросов является предметом отдельного рассмотрения. Приведем фрагмент такой типологии, чтобы проиллюстрировать  семантическую мощность sc-языка вопросов.
		</p>
		<p>
		Прежде всего, по аналогии с <i><sc_element sys_idtf = "logical_formula">логическими формулами</sc_element></i> множество вопросов разбивается на:
		</p>
		<ul>
			<li><b><sc_element sys_idtf = "atomic_question">атомарные вопросы;</sc_element></b></li>
			<li><b><sc_element sys_idtf = "non_atomic_question">неатомарные вопросы</sc_element></b>, каждый из которых представляет собой конечное множество вопросов.</li>
		</ul>
		<p>
		Компонентами неатомарного вопроса могут быть как атомарные, так и неатомарные вопросы. При этом, если построить орграф, вершинами которого будут знаки всех вопросов, входящих в состав заданного неатомарного вопроса, а дуги которого будут связывать знаки неатомарных вопросов, входящих в состав заданного неатомарного вопроса, с их компонентами, то этот орграф будет деревом, все конечные вершины которого являются знаками атомарных вопросов. Частным видом неатомарного вопроса является конъюнктивный вопрос, ответом на который является конъюнкция (интеграция) ответов на все вопросы, являющиеся компонентами этого конъюнктивного вопроса.
		</p>
		<p>
Поскольку в общем случае вопросу может соответствовать <u>несколько</u> правильных ответов (т.е. ответов, удовлетворяющих, релевантных, соответствующих заданному вопросу), множество вопросов разбивается на:
		</p>
		<ul>
			<li>вопросы, запрашивающие все правильные ответы;</li>
			<li>вопросы, запрашивающие один (или по крайней мере один) правильный ответ;</li>
			<li>вопросы, запрашивающие несколько разнообразных правильных ответов;</li>
			<li>вопросы, запрашивающие точно указанное число (большее единицы) правильных ответов.</li>
		</ul>
		<p>
		Специальным видом неатомарных вопросов являются <b><sc_element sys_idtf = "how_question">сколько-вопросы</sc_element></b>, запрашивающие не сами правильные ответы некоторого вопроса (который может быть как атомарным, так и неатомарным, и который является единственным компонентом сколько-вопроса), а количество таких правильных ответов.
		</p>
		<p>
		Приведем некоторые типы атомарных вопросов:
		</p>
		<ul>
			<li><b><sc_element sys_idtf = "which_question_of_atomic_type">какой-вопрос атомарного вида</sc_element></b>. Каждый такой вопрос запрашивает фрагменты базы знаний, <u>изоморфные</u> заданному <b>образцу</b>, который может иметь <u>произвольный</u> размер, произвольную конфигурацию и который может быть представлен не только <u>логической формулой существования</u> в которой квантор существования действует на конъюнкцию <u>атомарных логических формул</u>, но также и логической формулой существования, в которой квантор существования действует на логическую формулу <u>произвольного вида</u>. Суть атомарного <i><sc_element sys_idtf = "which_question_of_atomic_type">какой-вопроса</sc_element></i> заключается в поиске знаков таких объектов, которые заданным образом связаны с другими известными и неизвестными (искомыми) объектами, т.е. в поиске знаков таких объектов, которые удовлетворяют заданным требованиям. На основе <i><sc_element sys_idtf = "which_question_of_atomic_type">какой-вопросов</sc_element></i> атомарного вида строится важный класс неатомарных вопросов ключевыми компонентами которых являются атомарные какой-вопросы, а остальными компонентами – вопросы любого вида, в формулировках которых используются переменные, входящие в состав соответствующих ключевых <i><sc_element sys_idtf = "which_question_of_atomic_type">какой-вопросов;</sc_element></i></li>
			<li><b><sc_element sys_idtf = "request_of_all_elements">запрос всех элементов</sc_element></b> заданного конечного множества (чаще всего – это множество из элементов некоторой структуры);</li>
			<li><b><sc_element sys_idtf = "request_of_external_information_structure">запрос внешней информационной конструкции</sc_element></b>, представленной некоторым файлом в том или ином формате;</li>
			<li>запрос полного текста заданного высказывания;</li>
			<li><b><sc_element sys_idtf = "do_question">ли-вопрос</sc_element></b>, запрашивающий факт истинности или ложности заданного высказывания в рамках заданной формальной теории;</li>
			<li><b><sc_element sys_idtf = "question_of_choice_of_alternatives">вопрос выбора альтернатив</sc_element></b>, запрашивающий одно или несколько истинных высказываний из заданного множества высказываний;</li>
			<li><b><sc_element sys_idtf = "why_question">почему-вопрос</sc_element></b>, запрашивающий обоснование (доказательство) истинности заданного высказывания;</li>
			<li><b><sc_element sys_idtf = "what_is_question">что-это-вопрос</sc_element></b>, запрашивающий основные сведения об указываемом объекте. Фактически, речь идет о выделении из базы знаний семантической окрестности, "центром" которой является знак указываемого объекта. Таким объектом может быть все, что угодно – понятие, предметная область, формальная теория, высказывание, любая структура, материальный объект.</li>
			<li><b><sc_element sys_idtf = "request_of_the_general_properties">запрос общих свойств</sc_element></b> объектов, принадлежащих заданному классу;</li>
			<li><b><sc_element sys_idtf = "request_of_identification_signs">запрос идентифицирующих признаков</sc_element></b> заданного объекта. Здесь запрашиваются фрагменты базы знаний, каждый из которых <u>однозначно</u> (!) определяет (устанавливает, идентифицирует) заданный объект. Если заданным объектом является понятие, то таким идентифицирующим признаком является либо определение этого понятия, либо соответствующая теорема о необходимости и достаточности;</li>
			<li><b><sc_element sys_idtf = "request_of_connections_between_given_objects">запрос связей между заданными объектами;</sc_element></b></li>
			<li><b><sc_element sys_idtf = "request_of_comparative_analysis_of_given_objects">запрос сравнительного анализа заданных объектов;</sc_element></b></li>
			<li><b><sc_element sys_idtf = "request_of_similarities">запрос сходств</sc_element></b> заданных объектов (сходства, аналогии – это частный вид связей между объектами);</li>
			<li><b><sc_element sys_idtf = "request_of_differences">запрос отличий</sc_element></b> заданных объектов (отличия объектов – это тоже частный вид связей между ними);</li>
			<li><b><sc_element sys_idtf = "request_of_plan_decision">запрос плана решения</sc_element></b> заданной конкретной задачи, т.е. плана достижения заданной цели в заданных конкретных условиях;</li>
			<li><b><sc_element sys_idtf = "request_of_generalized_method_of_solving">запрос обобщенного способа решения</sc_element></b> любой задачи из заданного класса задач. Таким обобщенным способом может быть алгоритм, декларативная (непроцедурная) программа, нестрогое предписание (рекомендация);</li>
			<li><b><sc_element sys_idtf = "what_question">зачем-вопрос</sc_element></b>, запрашивающий то, какой надцели соответствует заданная цель, которая может быть сформулирована как в декларативной, так и в процедурной форме.</li>
		</ul>
		<p>
		Список типов атомарных вопросов можно продолжить, но почти все они будут подтипами (подмножествами) перечисленных типов вопросов. В основе sc-языка вопросов лежит построение онтологии вопросов, в рамках которой четко прописываются все теоретико-множественные (и, в первую очередь, родо-видовые) связи между <u>всеми</u> выделенными типами и подтипами вопросов. При этом в формулировке <u>каждого</u> конкретного 
sc-вопроса <u>явным образом</u> отражаются иерархия <u>всех</u> типов вопросов, которым принадлежит данный конкретный sc-вопрос. Для этого каждому типу вопросов ставится в соответствие ключевой sc-узел, обозначающий этот тип вопросов.
		</p>
		<p>
В заключение заметим, что в <b>SC-языке оформления ответов</b> кроме отношения релевантности, связывающего вопросы с правильными на него ответами, используются языковые средства, описывающие качество, полноту ответов. Это вызвано тем, что некоторые типы вопросов предполагают наличие целого множества правильных ответов, но разного качества, с разной степенью полноты.
		</p>
	</body>
</html>
